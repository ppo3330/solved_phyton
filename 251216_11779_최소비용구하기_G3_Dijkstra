#O(n^2 + nm + (n+m)logn )
#구현 자체는 그렇게 어려운게 아니었음.
#다익스트라 정점:n 간선:m -> O((n+m) log n)
#경로 복사: nm
#경로 복사를 prev로 하면 줄일 수 있음 -> 내일 cpp로 시도해보기
from queue import PriorityQueue

n = int(input())
m = int(input())

cities = []
buses = [[] for _ in range(n+1)]

arr = [[1e9]*(n+1) for _ in range(n+1)]

for i in range(m):
    a,b,c = map(int,input().split())
    arr[a][b] = min(arr[a][b],c)
    
for i in range(n+1):
    for j in range(n+1):
        if arr[i][j] <1e9:
            buses[i].append([arr[i][j],j])
        


a,b = map(int,input().split())
dist = [[1e9,i] for i in range(n+1)]
dist[a][0] = 0

result = [1e9]
q = PriorityQueue()
q.put((0,a))
while not q.empty():
    cur = q.get()[1]
    curcost = dist[cur][0]

    for nxt in buses[cur]:
        nxtcity = nxt[1]
        nxtcost = nxt[0]
        new_cost = curcost + nxtcost
        if curcost > dist[nxtcity][0]: continue
        if new_cost < dist[nxtcity][0]:
            dist[nxtcity][0] = new_cost
            dist[nxtcity] = [new_cost, nxtcity]
            for i in range(1,len(dist[cur])):
                dist[nxtcity].append(dist[cur][i])
            q.put((nxtcost,nxtcity))
            
print(dist[b][0])
print(len(dist[b])-1)
for i in range(len(dist[b])-1,0,-1):
    print(dist[b][i],end = ' ')
    
